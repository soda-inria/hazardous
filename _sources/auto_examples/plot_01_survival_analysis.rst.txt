
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_01_survival_analysis.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_01_survival_analysis.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_01_survival_analysis.py:


=====================================
Survival analysis with SurvivalBoost
=====================================

Survival analysis is a time-to-event regression problem that deals with censored data.
We refer to individuals as censored if they did not experience the event during the
period of observation.

In our setting, we are mostly interested in right-censored data, which means that the
event of interest did not occur before the end of the observation period (typically the
time of data collection).

We will use the The Molecular Taxonomy of Breast Cancer International Consortium
(METABRIC) dataset as an example, which is available through ``pycox.datasets``. This
is the processed data set used in the
`DeepSurv paper (Katzman et al. 2018) <https://doi.org/10.1186/s12874-018-0482-1>`_.

.. GENERATED FROM PYTHON SOURCE LINES 20-32

.. code-block:: Python

    import numpy as np
    import pandas as pd

    from pycox.datasets import metabric

    np.random.seed(0)

    df = metabric.read_df()
    X = df.drop(columns=["event", "duration"])
    y = df[["event", "duration"]]
    y





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Dataset 'metabric' not locally available. Downloading...
    Done


.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>event</th>
          <th>duration</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>0</td>
          <td>99.333336</td>
        </tr>
        <tr>
          <th>1</th>
          <td>1</td>
          <td>95.733330</td>
        </tr>
        <tr>
          <th>2</th>
          <td>0</td>
          <td>140.233337</td>
        </tr>
        <tr>
          <th>3</th>
          <td>0</td>
          <td>239.300003</td>
        </tr>
        <tr>
          <th>4</th>
          <td>1</td>
          <td>56.933334</td>
        </tr>
        <tr>
          <th>...</th>
          <td>...</td>
          <td>...</td>
        </tr>
        <tr>
          <th>1899</th>
          <td>1</td>
          <td>87.233330</td>
        </tr>
        <tr>
          <th>1900</th>
          <td>0</td>
          <td>157.533340</td>
        </tr>
        <tr>
          <th>1901</th>
          <td>1</td>
          <td>37.866665</td>
        </tr>
        <tr>
          <th>1902</th>
          <td>0</td>
          <td>198.433334</td>
        </tr>
        <tr>
          <th>1903</th>
          <td>0</td>
          <td>140.766663</td>
        </tr>
      </tbody>
    </table>
    <p>1904 rows × 2 columns</p>
    </div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 33-43

Notice that the target ``y`` is comprised of two columns:

- ``event``, where :math:`0` marks censoring and :math:`1` is indicative that the
  event of interest (death) has actually happened before the end of the
  observation window.
- ``duration``, the censored time-to-event :math:`D = \min(T, C) > 0`.
  This is the minimum between the date of the experienced event, represented by the
  random variable :math:`T`, and the censoring date, represented by :math:`C`.

In this dataset, approximately 42% of the data is censored..

.. GENERATED FROM PYTHON SOURCE LINES 46-48

.. code-block:: Python

    y["event"].value_counts(normalize=True)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    event
    1    0.579307
    0    0.420693
    Name: proportion, dtype: float64



.. GENERATED FROM PYTHON SOURCE LINES 49-54

.. code-block:: Python

    from sklearn.model_selection import train_test_split

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
    X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.2)








.. GENERATED FROM PYTHON SOURCE LINES 55-71

Using SurvivalBoost to estimate the survival function
-----------------------------------------------------

Here, our quantity of interest is the survival probability:

.. math::

    S(t | X=x) = P(T > t | X=x)

This represents the probability that an event doesn't occur at or before some
given time :math:`t`, i.e. that it happens at some time :math:`T > t`,
given the patient features :math:`x`.

SurvivalBoost is a scikit-learn compatible model which expects a covariates dataframe
(or array-like) ``X``, and a target dataframe ``y`` with columns "event" and
"duration". This allows SurvivalBoost to estimate the survival function :math:`S`.

.. GENERATED FROM PYTHON SOURCE LINES 72-78

.. code-block:: Python

    from hazardous import SurvivalBoost

    survival_boost = SurvivalBoost(show_progressbar=False).fit(X_train, y_train)

    survival_boost






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <style>#sk-container-id-1 {
      /* Definition of color scheme common for light and dark mode */
      --sklearn-color-text: black;
      --sklearn-color-line: gray;
      /* Definition of color scheme for unfitted estimators */
      --sklearn-color-unfitted-level-0: #fff5e6;
      --sklearn-color-unfitted-level-1: #f6e4d2;
      --sklearn-color-unfitted-level-2: #ffe0b3;
      --sklearn-color-unfitted-level-3: chocolate;
      /* Definition of color scheme for fitted estimators */
      --sklearn-color-fitted-level-0: #f0f8ff;
      --sklearn-color-fitted-level-1: #d4ebff;
      --sklearn-color-fitted-level-2: #b3dbfd;
      --sklearn-color-fitted-level-3: cornflowerblue;

      /* Specific color for light theme */
      --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
      --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, white)));
      --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
      --sklearn-color-icon: #696969;

      @media (prefers-color-scheme: dark) {
        /* Redefinition of color scheme for dark theme */
        --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
        --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, #111)));
        --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
        --sklearn-color-icon: #878787;
      }
    }

    #sk-container-id-1 {
      color: var(--sklearn-color-text);
    }

    #sk-container-id-1 pre {
      padding: 0;
    }

    #sk-container-id-1 input.sk-hidden--visually {
      border: 0;
      clip: rect(1px 1px 1px 1px);
      clip: rect(1px, 1px, 1px, 1px);
      height: 1px;
      margin: -1px;
      overflow: hidden;
      padding: 0;
      position: absolute;
      width: 1px;
    }

    #sk-container-id-1 div.sk-dashed-wrapped {
      border: 1px dashed var(--sklearn-color-line);
      margin: 0 0.4em 0.5em 0.4em;
      box-sizing: border-box;
      padding-bottom: 0.4em;
      background-color: var(--sklearn-color-background);
    }

    #sk-container-id-1 div.sk-container {
      /* jupyter's `normalize.less` sets `[hidden] { display: none; }`
         but bootstrap.min.css set `[hidden] { display: none !important; }`
         so we also need the `!important` here to be able to override the
         default hidden behavior on the sphinx rendered scikit-learn.org.
         See: https://github.com/scikit-learn/scikit-learn/issues/21755 */
      display: inline-block !important;
      position: relative;
    }

    #sk-container-id-1 div.sk-text-repr-fallback {
      display: none;
    }

    div.sk-parallel-item,
    div.sk-serial,
    div.sk-item {
      /* draw centered vertical line to link estimators */
      background-image: linear-gradient(var(--sklearn-color-text-on-default-background), var(--sklearn-color-text-on-default-background));
      background-size: 2px 100%;
      background-repeat: no-repeat;
      background-position: center center;
    }

    /* Parallel-specific style estimator block */

    #sk-container-id-1 div.sk-parallel-item::after {
      content: "";
      width: 100%;
      border-bottom: 2px solid var(--sklearn-color-text-on-default-background);
      flex-grow: 1;
    }

    #sk-container-id-1 div.sk-parallel {
      display: flex;
      align-items: stretch;
      justify-content: center;
      background-color: var(--sklearn-color-background);
      position: relative;
    }

    #sk-container-id-1 div.sk-parallel-item {
      display: flex;
      flex-direction: column;
    }

    #sk-container-id-1 div.sk-parallel-item:first-child::after {
      align-self: flex-end;
      width: 50%;
    }

    #sk-container-id-1 div.sk-parallel-item:last-child::after {
      align-self: flex-start;
      width: 50%;
    }

    #sk-container-id-1 div.sk-parallel-item:only-child::after {
      width: 0;
    }

    /* Serial-specific style estimator block */

    #sk-container-id-1 div.sk-serial {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: var(--sklearn-color-background);
      padding-right: 1em;
      padding-left: 1em;
    }


    /* Toggleable style: style used for estimator/Pipeline/ColumnTransformer box that is
    clickable and can be expanded/collapsed.
    - Pipeline and ColumnTransformer use this feature and define the default style
    - Estimators will overwrite some part of the style using the `sk-estimator` class
    */

    /* Pipeline and ColumnTransformer style (default) */

    #sk-container-id-1 div.sk-toggleable {
      /* Default theme specific background. It is overwritten whether we have a
      specific estimator or a Pipeline/ColumnTransformer */
      background-color: var(--sklearn-color-background);
    }

    /* Toggleable label */
    #sk-container-id-1 label.sk-toggleable__label {
      cursor: pointer;
      display: block;
      width: 100%;
      margin-bottom: 0;
      padding: 0.5em;
      box-sizing: border-box;
      text-align: center;
    }

    #sk-container-id-1 label.sk-toggleable__label-arrow:before {
      /* Arrow on the left of the label */
      content: "▸";
      float: left;
      margin-right: 0.25em;
      color: var(--sklearn-color-icon);
    }

    #sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {
      color: var(--sklearn-color-text);
    }

    /* Toggleable content - dropdown */

    #sk-container-id-1 div.sk-toggleable__content {
      max-height: 0;
      max-width: 0;
      overflow: hidden;
      text-align: left;
      /* unfitted */
      background-color: var(--sklearn-color-unfitted-level-0);
    }

    #sk-container-id-1 div.sk-toggleable__content.fitted {
      /* fitted */
      background-color: var(--sklearn-color-fitted-level-0);
    }

    #sk-container-id-1 div.sk-toggleable__content pre {
      margin: 0.2em;
      border-radius: 0.25em;
      color: var(--sklearn-color-text);
      /* unfitted */
      background-color: var(--sklearn-color-unfitted-level-0);
    }

    #sk-container-id-1 div.sk-toggleable__content.fitted pre {
      /* unfitted */
      background-color: var(--sklearn-color-fitted-level-0);
    }

    #sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {
      /* Expand drop-down */
      max-height: 200px;
      max-width: 100%;
      overflow: auto;
    }

    #sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {
      content: "▾";
    }

    /* Pipeline/ColumnTransformer-specific style */

    #sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {
      color: var(--sklearn-color-text);
      background-color: var(--sklearn-color-unfitted-level-2);
    }

    #sk-container-id-1 div.sk-label.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
      background-color: var(--sklearn-color-fitted-level-2);
    }

    /* Estimator-specific style */

    /* Colorize estimator box */
    #sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {
      /* unfitted */
      background-color: var(--sklearn-color-unfitted-level-2);
    }

    #sk-container-id-1 div.sk-estimator.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
      /* fitted */
      background-color: var(--sklearn-color-fitted-level-2);
    }

    #sk-container-id-1 div.sk-label label.sk-toggleable__label,
    #sk-container-id-1 div.sk-label label {
      /* The background is the default theme color */
      color: var(--sklearn-color-text-on-default-background);
    }

    /* On hover, darken the color of the background */
    #sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {
      color: var(--sklearn-color-text);
      background-color: var(--sklearn-color-unfitted-level-2);
    }

    /* Label box, darken color on hover, fitted */
    #sk-container-id-1 div.sk-label.fitted:hover label.sk-toggleable__label.fitted {
      color: var(--sklearn-color-text);
      background-color: var(--sklearn-color-fitted-level-2);
    }

    /* Estimator label */

    #sk-container-id-1 div.sk-label label {
      font-family: monospace;
      font-weight: bold;
      display: inline-block;
      line-height: 1.2em;
    }

    #sk-container-id-1 div.sk-label-container {
      text-align: center;
    }

    /* Estimator-specific */
    #sk-container-id-1 div.sk-estimator {
      font-family: monospace;
      border: 1px dotted var(--sklearn-color-border-box);
      border-radius: 0.25em;
      box-sizing: border-box;
      margin-bottom: 0.5em;
      /* unfitted */
      background-color: var(--sklearn-color-unfitted-level-0);
    }

    #sk-container-id-1 div.sk-estimator.fitted {
      /* fitted */
      background-color: var(--sklearn-color-fitted-level-0);
    }

    /* on hover */
    #sk-container-id-1 div.sk-estimator:hover {
      /* unfitted */
      background-color: var(--sklearn-color-unfitted-level-2);
    }

    #sk-container-id-1 div.sk-estimator.fitted:hover {
      /* fitted */
      background-color: var(--sklearn-color-fitted-level-2);
    }

    /* Specification for estimator info (e.g. "i" and "?") */

    /* Common style for "i" and "?" */

    .sk-estimator-doc-link,
    a:link.sk-estimator-doc-link,
    a:visited.sk-estimator-doc-link {
      float: right;
      font-size: smaller;
      line-height: 1em;
      font-family: monospace;
      background-color: var(--sklearn-color-background);
      border-radius: 1em;
      height: 1em;
      width: 1em;
      text-decoration: none !important;
      margin-left: 1ex;
      /* unfitted */
      border: var(--sklearn-color-unfitted-level-1) 1pt solid;
      color: var(--sklearn-color-unfitted-level-1);
    }

    .sk-estimator-doc-link.fitted,
    a:link.sk-estimator-doc-link.fitted,
    a:visited.sk-estimator-doc-link.fitted {
      /* fitted */
      border: var(--sklearn-color-fitted-level-1) 1pt solid;
      color: var(--sklearn-color-fitted-level-1);
    }

    /* On hover */
    div.sk-estimator:hover .sk-estimator-doc-link:hover,
    .sk-estimator-doc-link:hover,
    div.sk-label-container:hover .sk-estimator-doc-link:hover,
    .sk-estimator-doc-link:hover {
      /* unfitted */
      background-color: var(--sklearn-color-unfitted-level-3);
      color: var(--sklearn-color-background);
      text-decoration: none;
    }

    div.sk-estimator.fitted:hover .sk-estimator-doc-link.fitted:hover,
    .sk-estimator-doc-link.fitted:hover,
    div.sk-label-container:hover .sk-estimator-doc-link.fitted:hover,
    .sk-estimator-doc-link.fitted:hover {
      /* fitted */
      background-color: var(--sklearn-color-fitted-level-3);
      color: var(--sklearn-color-background);
      text-decoration: none;
    }

    /* Span, style for the box shown on hovering the info icon */
    .sk-estimator-doc-link span {
      display: none;
      z-index: 9999;
      position: relative;
      font-weight: normal;
      right: .2ex;
      padding: .5ex;
      margin: .5ex;
      width: min-content;
      min-width: 20ex;
      max-width: 50ex;
      color: var(--sklearn-color-text);
      box-shadow: 2pt 2pt 4pt #999;
      /* unfitted */
      background: var(--sklearn-color-unfitted-level-0);
      border: .5pt solid var(--sklearn-color-unfitted-level-3);
    }

    .sk-estimator-doc-link.fitted span {
      /* fitted */
      background: var(--sklearn-color-fitted-level-0);
      border: var(--sklearn-color-fitted-level-3);
    }

    .sk-estimator-doc-link:hover span {
      display: block;
    }

    /* "?"-specific style due to the `<a>` HTML tag */

    #sk-container-id-1 a.estimator_doc_link {
      float: right;
      font-size: 1rem;
      line-height: 1em;
      font-family: monospace;
      background-color: var(--sklearn-color-background);
      border-radius: 1rem;
      height: 1rem;
      width: 1rem;
      text-decoration: none;
      /* unfitted */
      color: var(--sklearn-color-unfitted-level-1);
      border: var(--sklearn-color-unfitted-level-1) 1pt solid;
    }

    #sk-container-id-1 a.estimator_doc_link.fitted {
      /* fitted */
      border: var(--sklearn-color-fitted-level-1) 1pt solid;
      color: var(--sklearn-color-fitted-level-1);
    }

    /* On hover */
    #sk-container-id-1 a.estimator_doc_link:hover {
      /* unfitted */
      background-color: var(--sklearn-color-unfitted-level-3);
      color: var(--sklearn-color-background);
      text-decoration: none;
    }

    #sk-container-id-1 a.estimator_doc_link.fitted:hover {
      /* fitted */
      background-color: var(--sklearn-color-fitted-level-3);
    }
    </style><div id="sk-container-id-1" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>SurvivalBoost(show_progressbar=False)</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator fitted sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-1" type="checkbox" checked><label for="sk-estimator-id-1" class="sk-toggleable__label fitted sk-toggleable__label-arrow fitted">&nbsp;SurvivalBoost<span class="sk-estimator-doc-link fitted">i<span>Fitted</span></span></label><div class="sk-toggleable__content fitted"><pre>SurvivalBoost(show_progressbar=False)</pre></div> </div></div></div></div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 79-84

SurvivalBoost can then predict the survival function for each patient,
according to some time grid of horizons.
**The time grid is learned during fit but can be passed during prediction**
with the parameter ``times``.
When ``times`` is set to ``None``, the model will used the learned time grid.

.. GENERATED FROM PYTHON SOURCE LINES 85-94

.. code-block:: Python


    predicted_curves = survival_boost.predict_cumulative_incidence(
        X_test,
        times=None,
    )

    survival_curves = predicted_curves[:, 0]  # survival function S(t)
    incidence_curves = predicted_curves[:, 1]  # cumulative incidence of the event (death)








.. GENERATED FROM PYTHON SOURCE LINES 95-96

Let's plot the estimated survival function for some patients.

.. GENERATED FROM PYTHON SOURCE LINES 96-127

.. code-block:: Python

    import matplotlib.pyplot as plt

    fig, ax = plt.subplots()

    patient_ids_to_plot = [0, 1, 2, 3]

    for idx in patient_ids_to_plot:
        ax.plot(survival_boost.time_grid_, survival_curves[idx], label=f"Patient {idx}")

        # plot symbols for death or censoring
        event = y_test.iloc[idx]["event"]
        duration = y_test.iloc[idx]["duration"]

        # find the index of time closest to duration
        jdx = np.searchsorted(survival_boost.time_grid_, duration)
        smiley = "☠️" if event == 1 else "✖"
        ax.text(
            duration,
            survival_curves[idx, jdx],
            smiley,
            fontsize=20,
            color=ax.lines[idx].get_color(),
        )

    ax.legend()
    ax.set_title("")
    ax.set_xlabel("Months")
    ax.set_ylabel("Predicted Survival Probability")

    plt.show()




.. image-sg:: /auto_examples/images/sphx_glr_plot_01_survival_analysis_001.png
   :alt: plot 01 survival analysis
   :srcset: /auto_examples/images/sphx_glr_plot_01_survival_analysis_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 128-138

Measuring features impact on predictions
----------------------------------------

We can also observe the survival function by age group or by chemotherapy treatment
to show the impact that the model attributes to these features. We do something akin
to Partial Dependence Plots, where we sample the feature independently of the other
features to eliminate correlations.

We create a synthetic dataset where age (``x8``) is resampled to reduce
confounder bias.

.. GENERATED FROM PYTHON SOURCE LINES 139-187

.. code-block:: Python


    X_synthetic = X_train.copy()
    # Age varies from 20 to 80
    X_synthetic["x8"] = np.linspace(20, 80, X_synthetic.shape[0])

    # Predict cumulative incidence on the synthetic dataset
    survival_curves_synthetic = survival_boost.predict_survival_function(X_synthetic)

    # Create age bins and sort them by the left bin edge
    age_bins = pd.cut(X_synthetic["x8"], bins=[0, 30, 40, 50, 60, 70, 80, 90, 100])
    age_groups = sorted(age_bins.unique(), key=lambda x: x.left)

    # Create a colormap
    fig, ax = plt.subplots()
    cmap = plt.get_cmap("viridis", len(age_groups))

    for idx, age_group in enumerate(age_groups):
        # Get the mask of patients in the current age group
        mask = age_bins == age_group

        # Calculate the mean and std cumulative incidence for the current age group
        mean_survival = survival_curves_synthetic[mask].mean(axis=0)
        std_survival = survival_curves_synthetic[mask].std(axis=0)

        # Plot with color from colormap
        ax.plot(
            survival_boost.time_grid_,
            mean_survival,
            label=f"Age {age_group}",
            color=cmap(idx),
            linewidth=3,
        )
        # Add ribbon for std
        ax.fill_between(
            survival_boost.time_grid_,
            mean_survival - std_survival,
            mean_survival + std_survival,
            color=cmap(idx),
            alpha=0.3,
        )

    ax.legend()
    ax.set_title("Survival function by age")
    ax.set_xlabel("Months")
    ax.set_ylabel("Estimated Survival Probability")

    plt.show()




.. image-sg:: /auto_examples/images/sphx_glr_plot_01_survival_analysis_002.png
   :alt: Survival function by age
   :srcset: /auto_examples/images/sphx_glr_plot_01_survival_analysis_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 188-193

Unsurprisingly, the cumulative incidence of death mostly increases with age.
We can do the same thing with chemotherapy treatement.

Let's create a synthetic dataset where chemotherapy (``x6``)
alternates between 0 and 1.

.. GENERATED FROM PYTHON SOURCE LINES 194-235

.. code-block:: Python


    X_synthetic = X_train.copy()
    X_synthetic["x6"] = np.tile([0, 1], X_synthetic.shape[0] // 2)

    survival_curves_synthetic = survival_boost.predict_survival_function(
        X_synthetic,
    )

    fig, ax = plt.subplots()
    cmap = plt.get_cmap("viridis", 2)

    for chemo_group in [0, 1]:
        mask = X_synthetic["x6"] == chemo_group
        mean_survival = survival_curves_synthetic[mask].mean(axis=0)
        std_survival = survival_curves_synthetic[mask].std(axis=0)
        ax.plot(
            survival_boost.time_grid_,
            mean_survival,
            label=(
                "Treated with Chemotherapy"
                if chemo_group == 1
                else "Not Treated with Chemotherapy"
            ),
            color=cmap(chemo_group),
            linewidth=3,
        )
        ax.fill_between(
            survival_boost.time_grid_,
            mean_survival - std_survival,
            mean_survival + std_survival,
            color=cmap(chemo_group),
            alpha=0.3,
        )

    ax.legend()
    ax.set_title("Survival function by chemotherapy treatment")
    ax.set_xlabel("Months")
    ax.set_ylabel("Estimated Survival Probability")

    plt.show()




.. image-sg:: /auto_examples/images/sphx_glr_plot_01_survival_analysis_003.png
   :alt: Survival function by chemotherapy treatment
   :srcset: /auto_examples/images/sphx_glr_plot_01_survival_analysis_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 236-304

People treated with chemotherapy likely have more advanced stages of cancer, which is
reflected by the lower estimated survival function. This serves as a reminder that
the estimate is not causal.

Let's now attempt to quantify how well a survival curve estimated on a training set
performs on a test set.

Survival model evaluation
-------------------------

The Brier score and the C-index are measures that **assess the quality of a
predicted survival curve** on a finite data sample.

- **The Brier score in time is a strictly proper scoring rule**, which means that an
  estimate of the survival probabilities at a given time :math:`t` has minimal Brier
  score if and only if it matches the oracle survival probabilities induced by
  the underlying data generating process. In that respect, the **Brier score**
  assesses both the **calibration** and the **ranking power** of a survival
  probability estimator. It is comprised between 0 and 1 (lower is better). It
  answers the question *"how close to the real probabilities are our estimates?"*.

- On the other hand, the **C-index** only assesses the **ranking power**: it
  represents the probability that, for a randomly selected pair of patients,
  the patient with the higher estimated survival probability will survive
  longer than the other. It is comprised between 0 and 1 (higher is better),
  with 0.5 corresponding to random predictions.

.. dropdown:: Mathematical formulation (Brier score)

    .. math::

        \mathrm{BS}^c(t) = \frac{1}{n} \sum_{i=1}^n I(d_i \leq t \cap \delta_i = 1)
        \frac{(0 - \hat{S}(t | \mathbf{x}_i))^2}{\hat{G}(d_i)} + I(d_i > t)
        \frac{(1 - \hat{S}(t | \mathbf{x}_i))^2}{\hat{G}(t)}

    In the survival analysis context, the Brier Score can be seen as the Mean
    Squared Error (MSE) between our probability :math:`\hat{S}(t)` and our
    target label :math:`\delta_i \in {0, 1}`, weighted by the inverse probability
    of censoring :math:`\frac{1}{\hat{G}(t)}`.
    In practice we estimate :math:`\hat{G}(t)` using a variant of
    the Kaplan-Estimator with swapped event indicator.

    - When no event or censoring has happened at :math:`t` yet, i.e.
      :math:`I(d_i > t)`, we penalize a low probability of survival with
      :math:`(1 - \hat{S}(t|\mathbf{x}_i))^2`.
    - Conversely, when an individual has experienced an event before :math:`t`, i.e.
      :math:`I(d_i \leq t \cap \delta_i = 1)`, we penalize a high probability
      of survival with :math:`(0 - \hat{S}(t|\mathbf{x}_i))^2`.

.. dropdown:: Mathematical formulation (Harrell's C-index)

    .. math::

        \mathrm{C_{index}} = \frac{\sum_{i,j} I(d_i < d_j \space \cap \space
        \delta_i = 1 \space \cap \space \mu_i < \mu_j)}
        {\sum_{i,j} I(d_i < d_j \space \cap \space \delta_i = 1)}

    where :math:`\mu_i` and :math:`\mu_j` are the time-averaged predicted survival
    probabilities for individual :math:`i` and :math:`j`.

Additionnaly, we compute the Integrated Brier Score (IBS), which we will use to
summarize the Brier score in time:

.. math::

    \mathrm{IBS} = \frac{1}{t_{max} - t_{min}}\int^{t_{max}}_{t_{min}}
    \mathrm{BS(t)} dt


.. GENERATED FROM PYTHON SOURCE LINES 305-315

.. code-block:: Python

    from hazardous.metrics import integrated_brier_score_survival

    ibs_survboost = integrated_brier_score_survival(
        y_train,
        y_test,
        survival_curves,
        times=survival_boost.time_grid_,
    )
    print(f"IBS for SurvivalBoost: {ibs_survboost:.4f}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    IBS for SurvivalBoost: 0.1382




.. GENERATED FROM PYTHON SOURCE LINES 316-318

We can compare this to the Integrated Brier score of a simple Kaplan-Meier estimator,
which doesn't take the patient features into account.

.. GENERATED FROM PYTHON SOURCE LINES 319-339

.. code-block:: Python

    from lifelines import KaplanMeierFitter

    km_model = KaplanMeierFitter()
    km_model.fit(y["duration"], y["event"])
    survival_curve_agg_km = km_model.survival_function_at_times(
        survival_boost.time_grid_,
    )

    # To get individual survival curves, we duplicate the survival curve for each patient.
    survival_curves_km = np.tile(survival_curve_agg_km, (X_test.shape[0], 1))

    ibs_km = integrated_brier_score_survival(
        y_train,
        y_test,
        survival_curves_km,
        times=survival_boost.time_grid_,
    )
    print(f"IBS for Kaplan-Meier: {ibs_km:.4f}")






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    IBS for Kaplan-Meier: 0.1566




.. GENERATED FROM PYTHON SOURCE LINES 340-341

Let's also compute the concordance index for both the Kaplan-Meier and SurvivalBoost.

.. GENERATED FROM PYTHON SOURCE LINES 344-353

.. code-block:: Python

    from lifelines.utils import concordance_index

    concordance_index_km = concordance_index(
        event_observed=y_test["event"],
        event_times=y_test["duration"],
        predicted_scores=survival_curves_km.mean(axis=1),
    )
    print(f"Concordance index for Kaplan-Meier: {concordance_index_km:.2f}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Concordance index for Kaplan-Meier: 0.50




.. GENERATED FROM PYTHON SOURCE LINES 354-357

0.5 corresponds to random chance, which makes sense as the Kaplan-Meier estimator
doesn't depend on the patient features.


.. GENERATED FROM PYTHON SOURCE LINES 358-365

.. code-block:: Python

    concordance_index_survboost = concordance_index(
        event_observed=y_test["event"],
        event_times=y_test["duration"],
        predicted_scores=survival_curves.mean(axis=1),
    )
    print(f"Concordance index for SurvivalBoost: {concordance_index_survboost:.2f}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Concordance index for SurvivalBoost: 0.67





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 6.879 seconds)


.. _sphx_glr_download_auto_examples_plot_01_survival_analysis.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_01_survival_analysis.ipynb <plot_01_survival_analysis.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_01_survival_analysis.py <plot_01_survival_analysis.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_01_survival_analysis.zip <plot_01_survival_analysis.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
